# Clarificación y checklist
@Structure.md Actuá como arquitecto. Crea un brief para este proyecto y lista las 10 preguntas clave que debo resolver antes de decidir la arquitectura.
incluye NFRs propuestos con SLIs/SLOs iniciales.

# Eleccion inicial de estilo
“Decisión inicial típica: Monolito Modular + Clean Architecture, con eventos in-process. Plan de evolución hacia microservicios/EDA si aparecen cuellos.”

# Comparación rápida
Compara Monolito Modular vs Microservicios vs EDA para el brief anterior.
Usa NFRs dados y equipo actual. Dame pros/contras/risks y recomendación.

# Generar ADR
Genera un ADR: “Iniciar con Monolito Modular + Clean Architecture”.
Contexto, Decisión, Consecuencias (positivas/negativas) y Criterios de revisión.

---

# Dominios y límites (bounded contexts)
Definimos módulos: users, catalog, cart, orders, payments, notifications.
 Cada módulo propietario de sus tablas; nada de queries cruzadas. Comunicación interna por casos de uso y eventos.
Propón bounded contexts y contratos (use cases + eventos) para
users, catalog, cart, orders, payments, notifications.
Incluye ejemplos de payloads.

# Estructura de proyecto + esqueleto
“Creamos repo con Clean: dominio → aplicación → adaptadores → infraestructura.”

```
/IA Telegram Bot/
├── node_modules/
├── src/                
│   ├── modules/        
│   │   ├── TelegramBot.ts        (Manejo de la conexión y comandos del bot)
│   │   ├── DocumentIngestor.ts   (Gestiona la recepción y envío de archivos a la capa de Vectorización)
│   │   ├── VectorStoreClient.ts  (Maneja la conexión y consulta al Vector Store/Base de Datos de Vectores)
│   │   ├── AIProcessor.ts        (Implementa la lógica RAG: combina contexto y llama al LLM)
│   │   ├── Interfaces.ts         (Definiciones de tipos de datos, crucial para la mantenibilidad)
│   │   └── DataStructures.ts     (Define clases para manejar datos, e.g., DocumentChunk)
│   └── index.ts              
├── dist/               
├── package.json        
└── tsconfig.json
```

```ts
// domain/Product.ts
export class Product {
  constructor(public readonly id:string, public name:string, private _price:number) {}
  changePrice(newPrice:number) { if (newPrice<=0) throw new Error("InvalidPrice"); this._price=newPrice; }
  get price(){ return this._price; }
}

// application/ports/ProductRepository.ts
import { Product } from "../../domain/Product";
export interface ProductRepository { findById(id:string):Promise<Product|null>; save(p:Product):Promise<void> }

// application/use-cases/UpdateProductPrice.ts
import { ProductRepository } from "../ports/ProductRepository";
export class UpdateProductPrice {
  constructor(private repo:ProductRepository){}
  async execute({id,price}:{id:string;price:number}) {
    const p = await this.repo.findById(id); if(!p) throw new Error("NotFound");
    p.changePrice(price); await this.repo.save(p); return {id, price:p.price};
  }
}
```

Genera un esqueleto de proyecto Node.js + TypeScript + Express + pg + vitest con la estructura anterior. Incluye scripts NPM, tsconfig, eslint, y un healthcheck GET /health.

# Contratos HTTP + validación
“Versionamos API (/v1/*), validamos con JSON Schema/Zod, y separamos DTOs.”

Define endpoints REST v1 para cart y orders (crear carrito, añadir item, checkout).
Incluye JSON Schemas de request/response y códigos de error.

# Eventos internos y plan EDA
“Usamos eventos internos hoy y dejamos preparado el lenguaje para EDA:
 OrderPlaced, PaymentCaptured, OrderShipped.”

"Propón esquemas de eventos para OrderPlaced, PaymentCaptured (v1) con reglas de
compatibilidad. Describe cómo aplicar Outbox pattern en Postgres y qué columnas crear.

# Observabilidad, seguridad y datos
“Observabilidad: logs estructurados (cid), métricas (latencia P95, error rate), trazas.
 Seguridad: OIDC/JWT, RBAC básico, rate limiting, secrets en vault.
 Datos: Postgres (OLTP), Redis (cache/sesión), S3 para archivos. Migraciones versionadas.”

# Estrategia de despliegue

“Despliegue: Docker + docker-compose dev, CI/CD (lint, test, build, migrate, deploy).
 Pruebas:
- Unit (dominio y casos de uso con in-memory),
- Integration (adaptadores),
- Contract (puertos/adaptadores),
- E2E mínimo para checkout.”

Escribe un pipeline YAML (GitHub Actions) para: install (pnpm), lint, test (vitest),
build, ejecutar migraciones con Prisma/Knex, y desplegar a Fly.io/Render/Heroku.


# Eovlucion a microservicios

Planifica la extracción del módulo 'payments' a un microservicio.
Define contratos HTTP/eventos, estrategia de datos, idempotencia y pasos de migración.
Incluye riesgos y mitigaciones.



